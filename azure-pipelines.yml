trigger:
- main

# Pipeline Parameters - Can be customized when running the pipeline
parameters:
- name: app_name
  displayName: 'Application Name'
  type: string
  default: 'flask-app'

- name: admin_username
  displayName: 'VM Admin Username'
  type: string
  default: 'azureuser'

- name: environment
  displayName: 'Environment'
  type: string
  default: 'dev'
  values:
  - dev
  - staging
  - prod

- name: location
  displayName: 'Azure Location'
  type: string
  default: 'East US'

- name: vm_size
  displayName: 'VM Size'
  type: string
  default: 'Standard_B2s'

- name: resource_group_name
  displayName: 'Resource Group Name'
  type: string
  default: 'rg-flask-app-dev-ank'

- name: vm_name
  displayName: 'VM Name'
  type: string
  default: 'vm-flask-app-dev-ank'

# Pipeline Variables
variables:
  # Azure service connection name
  serviceConnectionName: 'annkitsubserviceconnection'
  
  # Note: Azure authentication variables (client_id, client_secret, tenant_id, subscription_id)
  # are automatically provided by the Azure DevOps service connection
  
  # IMPORTANT: Create a secret variable in Azure DevOps:
  # 1. Go to Pipeline > Edit > Variables
  # 2. Add variable: VM_ADMIN_PASSWORD (mark as secret)
  # 3. Set the value to your VM admin password

stages:
# Validate Stage
- stage: 'Validate'
  displayName: 'Validate Terraform Configuration'
  jobs:
  - job: 'ValidateTerraform'
    displayName: 'Validate Terraform'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - script: |
        # Install Terraform
        wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
        sudo apt update
        sudo apt install -y terraform
        
        # Validate Terraform configuration
        cd terraform
        terraform init
        terraform validate
      displayName: 'Validate Terraform Configuration'

# Setup Stage
- stage: 'Setup'
  displayName: 'Setup Environment'
  dependsOn: 'Validate'
  jobs:
  - job: 'SetupEnvironment'
    displayName: 'Setup Environment'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - script: |
        # Install required packages
        wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
        sudo apt update
        sudo apt install -y terraform sshpass
      displayName: 'Install Required Tools'

# Deploy Infrastructure Stage  
- stage: 'Deploy'
  displayName: 'Deploy Infrastructure'
  dependsOn: 'Setup'
  variables:
  - name: admin_password
    value: $[variables.VM_ADMIN_PASSWORD]  # Reference to Azure DevOps secret variable
  
  jobs:
  - job: 'DeployInfrastructure'
    displayName: 'Deploy with Terraform'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: AzureCLI@2
      displayName: 'Deploy Infrastructure'
      name: 'TerraformDeploy'
      inputs:
        azureSubscription: '$(serviceConnectionName)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
            # Install Terraform
            wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg >/dev/null
            echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list >/dev/null
            sudo apt update >/dev/null
            sudo apt install -y terraform sshpass >/dev/null
            
            # Setup Terraform working directory
            cd terraform
            
            # Use pipeline parameters directly (no dynamic generation)
            RESOURCE_GROUP_NAME="${{ parameters.resource_group_name }}"
            VM_NAME="${{ parameters.vm_name }}"
            
            # Initialize and apply Terraform with all variables
            terraform init >/dev/null
            
            terraform apply -auto-approve \
              -var="app_name=${{ parameters.app_name }}" \
              -var="admin_username=${{ parameters.admin_username }}" \
              -var="admin_password=$(admin_password)" \
              -var="environment=${{ parameters.environment }}" \
              -var="location=${{ parameters.location }}" \
              -var="vm_size=${{ parameters.vm_size }}" \
              -var="resource_group_name=$RESOURCE_GROUP_NAME" \
              -var="vm_name=$VM_NAME"
            
            if [ $? -ne 0 ]; then
              echo "ERROR: Terraform apply failed!"
              exit 1
            fi
            
            # Get VM public IP
            VM_PUBLIC_IP=$(terraform output -raw vm_public_ip 2>/dev/null)
            if [ -z "$VM_PUBLIC_IP" ] || [ "$VM_PUBLIC_IP" = "null" ]; then
              # Fallback to Azure CLI
              EXPECTED_PIP_NAME="${VM_NAME}-pip"
              VM_PUBLIC_IP=$(az network public-ip show --resource-group "$RESOURCE_GROUP_NAME" --name "$EXPECTED_PIP_NAME" --query ipAddress --output tsv 2>/dev/null)
              if [ -z "$VM_PUBLIC_IP" ] || [ "$VM_PUBLIC_IP" = "null" ]; then
                echo "ERROR: Could not retrieve VM public IP"
                exit 1
              fi
            fi
            
            # Set pipeline variables
            echo "##vso[task.setvariable variable=vm_public_ip;isOutput=true]$VM_PUBLIC_IP"
            echo "##vso[task.setvariable variable=resource_group_name;isOutput=true]$RESOURCE_GROUP_NAME"
            echo "##vso[task.setvariable variable=vm_name;isOutput=true]$VM_NAME"

# Package Application Stage
- stage: 'Package_Application'
  displayName: 'Package Application'
  dependsOn: 'Setup'
  jobs:
  - job: 'PackageApp'
    displayName: 'Package Application Files'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - script: |
        # Create temp directory for application files
        mkdir -p $(Agent.TempDirectory)/app-files
        
        # Copy application files
        if [ -d "sample-python-app" ]; then
          cp -r sample-python-app/* $(Agent.TempDirectory)/app-files/
        else
          echo "ERROR: sample-python-app directory not found"
          exit 1
        fi
      displayName: 'Package Application Files'
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Application Files'
      inputs:
        targetPath: '$(Agent.TempDirectory)/app-files'
        artifact: 'application-files'

# Deploy Application Stage
- stage: 'Deploy_Application'
  displayName: 'Deploy Application to VM'
  dependsOn: ['Deploy', 'Package_Application']
  variables:
    vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_public_ip'] ]
    resource_group_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.resource_group_name'] ]
    vm_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_name'] ]
    admin_password: $[variables.VM_ADMIN_PASSWORD]  # Reference to Azure DevOps secret variable
  
  jobs:
  - job: 'DeployToVM'
    displayName: 'Deploy Application to VM'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Application Files'
      inputs:
        buildType: 'current'
        artifactName: 'application-files'
        targetPath: '$(Agent.TempDirectory)/app-files'
    
    - script: |
        # Install sshpass for password authentication
        sudo apt update >/dev/null
        sudo apt install -y sshpass >/dev/null
        
        # Get VM IP with fallback logic
        VM_IP="$(vm_public_ip)"
        if [ -z "$VM_IP" ] || [ "$VM_IP" = "null" ]; then
          # Try to get from Azure CLI as fallback
          RESOURCE_GROUP="$(resource_group_name)"
          VM_NAME="$(vm_name)"
          
          if [ -n "$RESOURCE_GROUP" ] && [ -n "$VM_NAME" ]; then
            PIP_NAME=$(az network public-ip list --resource-group "$RESOURCE_GROUP" --query "[0].name" --output tsv 2>/dev/null)
            if [ -n "$PIP_NAME" ] && [ "$PIP_NAME" != "null" ]; then
              VM_IP=$(az network public-ip show --resource-group "$RESOURCE_GROUP" --name "$PIP_NAME" --query ipAddress --output tsv 2>/dev/null)
            fi
          fi
        fi
        
        if [ -z "$VM_IP" ] || [ "$VM_IP" = "null" ]; then
          echo "ERROR: VM IP is not available!"
          exit 1
        fi
        
        # Test connection with password authentication
        sshpass -p "$(admin_password)" ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no ${{ parameters.admin_username }}@$VM_IP "echo 'SSH connected'" >/dev/null
        
        # Create application directory and copy files
        APP_NAME="${{ parameters.app_name }}"
        sshpass -p "$(admin_password)" ssh -o StrictHostKeyChecking=no ${{ parameters.admin_username }}@$VM_IP "mkdir -p /home/${{ parameters.admin_username }}/$APP_NAME"
        sshpass -p "$(admin_password)" scp -o StrictHostKeyChecking=no -r $(Agent.TempDirectory)/app-files/* ${{ parameters.admin_username }}@$VM_IP:/home/${{ parameters.admin_username }}/$APP_NAME/ >/dev/null
        
        # Copy and run setup script
        sshpass -p "$(admin_password)" scp -o StrictHostKeyChecking=no terraform/scripts/setup.sh ${{ parameters.admin_username }}@$VM_IP:/tmp/setup.sh
        sshpass -p "$(admin_password)" ssh -o StrictHostKeyChecking=no ${{ parameters.admin_username }}@$VM_IP "echo '$(admin_password)' | sudo -S bash /tmp/setup.sh '${{ parameters.app_name }}' '${{ parameters.admin_username }}'"
        
        echo "Application deployed successfully"
      displayName: 'Deploy Application to VM'

# Validation Stage
- stage: 'Validate_Deployment'
  displayName: 'Final Validation and Testing'
  dependsOn: 'Deploy_Application'
  variables:
    vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_public_ip'] ]
  
  jobs:
  - job: 'ValidateApp'
    displayName: 'Validate Application'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: AzureCLI@2
      displayName: 'Test Application'
      inputs:
        azureSubscription: '$(serviceConnectionName)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Debug: Show all available environment variables
          echo "=== DEBUGGING VM IP RETRIEVAL ==="
          echo "Raw vm_public_ip variable: '$(vm_public_ip)'"
          
          VM_IP="$(vm_public_ip)"
          echo "VM_IP after assignment: '$VM_IP'"
          
          # If VM IP is empty, try to get it from Azure CLI as fallback
          if [ -z "$VM_IP" ] || [ "$VM_IP" = "null" ]; then
            echo "VM IP is empty or null, trying Azure CLI fallback..."
            
            # Try to find the VM and get its IP
            echo "Searching for VMs with pattern: ${{ parameters.vm_name }}"
            VM_IP=$(az vm list-ip-addresses --query "[?contains(virtualMachine.name, '${{ parameters.vm_name }}')].virtualMachine.network.publicIpAddresses[0].ipAddress" --output tsv 2>/dev/null | head -1)
            
            if [ -n "$VM_IP" ] && [ "$VM_IP" != "null" ]; then
              echo "Found VM IP via Azure CLI: $VM_IP"
            else
              echo "Could not find VM IP via Azure CLI either"
              echo "Available VMs:"
              az vm list --query "[].{Name:name, ResourceGroup:resourceGroup}" --output table 2>/dev/null || echo "Failed to list VMs"
              exit 1
            fi
          fi
          
          echo "Final VM IP to test: $VM_IP"
          
          # Wait for application to be ready
          echo "Testing application at IP: $VM_IP"
          sleep 30
          
          # Test multiple endpoints to ensure application is working
          echo "Testing health endpoint..."
          if curl -f -s --connect-timeout 10 "http://$VM_IP/health" >/dev/null 2>&1; then
            echo "Health endpoint responding"
          else
            echo "Health endpoint failed, trying home page..."
            if curl -f -s --connect-timeout 10 "http://$VM_IP/" >/dev/null 2>&1; then
              echo "Home page responding"
            else
              echo "Application validation failed - no endpoints responding"
              echo "Debugging information:"
              echo "VM IP: $VM_IP"
              curl -v "http://$VM_IP/" 2>&1 || echo "No response from VM"
              exit 1
            fi
          fi
          
          echo "Application validation successful"