# Azure DevOps Pipeline for Python Flask App Deployment
# This pipeline creates SSH keys, provisions infrastructure, and deploys the application

trigger:
  branches:
    include:
    - main
    - develop
  paths:
    exclude:
    - README.md
    - docs/*

pr:
  branches:
    include:
    - main

variables:
  # Pipeline Configuration
  terraform_version: '1.5.0'
  python_version: '3.11'
  
  # Azure Service Connection Configuration
  # Service connection 'annkitsubserviceconnection' is configured in Azure DevOps
  azureServiceConnection: 'annkitsubserviceconnection'
  azureSubscriptionId: '1c756cca-f6af-4af6-b2a3-cd9e449ade18'
  
  # Application Configuration
  app_name: 'python-flask-app'
  resource_group_prefix: 'rg-flask-app'
  vm_name_prefix: 'vm-flask'
  location: 'East US'
  
  # SSH Configuration
  ssh_key_name: 'flask-app-key'
  admin_username: 'azureuser'

stages:
- stage: 'Validate'
  displayName: 'Validate and Prepare'
  jobs:
  - job: 'ValidateCode'
    displayName: 'Validate Code and Configuration'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: AzureCLI@2
      displayName: 'Install Terraform and Generate SSH Keys'
      inputs:
        azureSubscription: $(azureServiceConnection)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Install Terraform
          echo "Installing Terraform $(terraform_version)..."
          wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
          sudo apt update && sudo apt install terraform
          
          terraform version
          
          echo "Generating SSH key pair..."
          
          # Create .ssh directory if it doesn't exist
          mkdir -p ~/.ssh
          
          # Generate SSH key pair
          ssh-keygen -t rsa -b 4096 -C "$(app_name)-$(Build.BuildId)" -f ~/.ssh/$(ssh_key_name) -N ""
          
          # Read the public key
          SSH_PUBLIC_KEY=$(cat ~/.ssh/$(ssh_key_name).pub)
          SSH_PRIVATE_KEY=$(cat ~/.ssh/$(ssh_key_name))
          
          echo "SSH key pair generated successfully"
          echo "Public key: $SSH_PUBLIC_KEY"
          
          # Set pipeline variables for use in later stages
          echo "##vso[task.setvariable variable=ssh_public_key;isOutput=true;isSecret=false]$SSH_PUBLIC_KEY"
          echo "##vso[task.setvariable variable=ssh_private_key;isOutput=true;isSecret=true]$SSH_PRIVATE_KEY"
          
          # Save keys as pipeline artifacts
          echo "$SSH_PUBLIC_KEY" > $(Agent.TempDirectory)/ssh_public_key.pub
          echo "$SSH_PRIVATE_KEY" > $(Agent.TempDirectory)/ssh_private_key
          
          # Set file permissions
          chmod 600 $(Agent.TempDirectory)/ssh_private_key
          chmod 644 $(Agent.TempDirectory)/ssh_public_key.pub
          
          echo "SSH keys saved to artifacts"
      name: 'PrepareEnvironment'
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish SSH Keys'
      inputs:
        targetPath: '$(Agent.TempDirectory)'
        artifact: 'ssh-keys'
        publishLocation: 'pipeline'
    
    - script: |
        cd terraform
        terraform fmt -check -recursive
        terraform init -backend=false
        terraform validate
      displayName: 'Validate Terraform Configuration'
    
    - task: UsePythonVersion@0
      displayName: 'Setup Python'
      inputs:
        versionSpec: $(python_version)
    
    - script: |
        cd sample-python-app
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        python -m py_compile app.py
      displayName: 'Validate Python Application'

- stage: 'Deploy'
  displayName: 'Deploy Infrastructure and Application'
  dependsOn: 'Validate'
  # Removed branch condition for testing - deploy on any branch
  # condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  variables:
    ssh_public_key: $[ stageDependencies.Validate.ValidateCode.outputs['PrepareEnvironment.ssh_public_key'] ]
    ssh_private_key: $[ stageDependencies.Validate.ValidateCode.outputs['PrepareEnvironment.ssh_private_key'] ]
  
  jobs:
  - deployment: 'DeployInfrastructure'
    displayName: 'Deploy Azure Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            displayName: 'Checkout Repository'
          
          - task: DownloadPipelineArtifact@2
            displayName: 'Download SSH Keys'
            inputs:
              buildType: 'current'
              artifactName: 'ssh-keys'
              targetPath: '$(Agent.TempDirectory)/ssh-keys'
          
          - task: AzureCLI@2
            displayName: 'Deploy Infrastructure with Terraform'
            name: 'TerraformDeploy'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e  # Exit on any error
                
                echo "Installing Terraform..."
                wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
                echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
                sudo apt update && sudo apt install terraform
                
                # Set fixed resource names for development environment
                ENVIRONMENT_NAME="dev"
                RESOURCE_GROUP_NAME="$(resource_group_prefix)-${ENVIRONMENT_NAME}"
                VM_NAME="$(vm_name_prefix)-${ENVIRONMENT_NAME}"
                
                # Validate SSH key
                if [ -z "$(ssh_public_key)" ]; then
                  echo "ERROR: SSH Public Key is missing!"
                  exit 1
                fi
                
                cd terraform
                terraform init
                terraform plan \
                  -var="resource_group_name=$RESOURCE_GROUP_NAME" \
                  -var="location=$(location)" \
                  -var="vm_name=$VM_NAME" \
                  -var="admin_username=$(admin_username)" \
                  -var="admin_ssh_key=$(ssh_public_key)" \
                  -var="app_name=$(app_name)" \
                  -var="subscription_id=$(azureSubscriptionId)" \
                  -out=tfplan
                
                # Apply deployment
                if ! terraform apply -auto-approve tfplan; then
                  echo "ERROR: Terraform apply failed!"
                  terraform show || echo "No state to show"
                  exit 1
                fi
                
                # Get VM public IP
                VM_PUBLIC_IP=$(terraform output -raw vm_public_ip 2>/dev/null)
                if [ -z "$VM_PUBLIC_IP" ] || [ "$VM_PUBLIC_IP" = "null" ]; then
                  # Fallback to Azure CLI
                  EXPECTED_PIP_NAME="${VM_NAME}-pip"
                  VM_PUBLIC_IP=$(az network public-ip show --resource-group "$RESOURCE_GROUP_NAME" --name "$EXPECTED_PIP_NAME" --query ipAddress --output tsv 2>/dev/null)
                  if [ -z "$VM_PUBLIC_IP" ] || [ "$VM_PUBLIC_IP" = "null" ]; then
                    echo "ERROR: Could not retrieve VM public IP"
                    exit 1
                  fi
                fi
                
                # Set pipeline variables
                echo "##vso[task.setvariable variable=vm_public_ip;isOutput=true]$VM_PUBLIC_IP"
                echo "##vso[task.setvariable variable=resource_group_name;isOutput=true]$RESOURCE_GROUP_NAME"
                echo "##vso[task.setvariable variable=vm_name;isOutput=true]$VM_NAME"
                
                echo "Infrastructure deployed successfully. VM IP: $VM_PUBLIC_IP"

- stage: 'Deploy_Application'
  displayName: 'Deploy Application to VM'
  dependsOn: 'Deploy'
  variables:
    vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_public_ip'] ]
    resource_group_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.resource_group_name'] ]
    vm_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_name'] ]
  
  jobs:
  - job: 'DeployToVM'
    displayName: 'Deploy Application via SSH'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download SSH Keys'
      inputs:
        buildType: 'current'
        artifactName: 'ssh-keys'
        targetPath: '$(Agent.TempDirectory)/ssh-keys'
    
    - task: PublishPipelineArtifact@1
      displayName: 'Package Application Files'
      inputs:
        targetPath: 'sample-python-app'
        artifact: 'application-files'
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Application Files'
      inputs:
        buildType: 'current'
        artifactName: 'application-files'
        targetPath: '$(Agent.TempDirectory)/app-files'
    
    - script: |
        # Setup SSH key
        mkdir -p ~/.ssh
        cp $(Agent.TempDirectory)/ssh-keys/ssh_private_key ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        VM_IP="$(vm_public_ip)"
        if [ -z "$VM_IP" ]; then
          echo "ERROR: VM IP is not available!"
          exit 1
        fi
        
        # Add VM to known hosts and test SSH
        ssh-keyscan -H $VM_IP >> ~/.ssh/known_hosts
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "echo 'SSH connection successful'"
        
        # Create application directory and copy files
        APP_NAME="$(app_name)"
        ssh $(admin_username)@$VM_IP "mkdir -p /home/$(admin_username)/$APP_NAME"
        scp -r $(Agent.TempDirectory)/app-files/* $(admin_username)@$VM_IP:/home/$(admin_username)/$APP_NAME/
        
        # Wait for VM setup to complete
        echo "Waiting for nginx installation..."
        for i in {1..20}; do
          if ssh $(admin_username)@$VM_IP "sudo systemctl is-active nginx >/dev/null 2>&1"; then
            echo "VM setup completed successfully"
            break
          fi
          sleep 30
          if [ $i -eq 20 ]; then
            echo "ERROR: VM setup timeout"
            exit 1
          fi
        done
      displayName: 'Wait for VM Initialization'
    
    - script: |
        echo "Checking VM setup status before deployment..."
        VM_IP="$(vm_public_ip_final)"
        
        # Check VM setup status
        echo "Verifying VM setup completion..."
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "echo 'SSH connection working'"
        
        # Check if setup log exists and show recent entries
        echo "Checking setup log..."
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "tail -10 /var/log/app-setup.log 2>/dev/null || echo 'Setup log not found'"
        
        # Check basic services
        echo "Checking basic services..."
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "sudo systemctl is-active nginx && echo 'Nginx is active' || echo 'Nginx is not active'"
        
        echo "VM status check completed, proceeding with deployment..."
      displayName: 'Check VM Status'
    
    - script: |
        echo "Deploying application to VM..."
        VM_IP="$(vm_public_ip_final)"
        
        # Create deployment script
        cat > deploy_app.sh << 'EOF'
        #!/bin/bash
        set -e
        
        APP_NAME="${app_name}"
        APP_DIR="/home/$(admin_username)/$APP_NAME"
        
        echo "=== APPLICATION DEPLOYMENT ==="
        echo "App Name: $APP_NAME"
        echo "App Directory: $APP_DIR"
        echo "Current User: $(whoami)"
        echo "=============================="
        
        # Check if app directory exists
        if [ ! -d "$APP_DIR" ]; then
            echo "âŒ ERROR: Application directory not found: $APP_DIR"
            echo "Available directories in /home/$(admin_username):"
            ls -la /home/$(admin_username)/
            exit 1
        fi
        
        # Navigate to app directory
        cd $APP_DIR
        echo "Current directory: $(pwd)"
        echo "Directory contents:"
        ls -la
        
        # Check if this is a git repository and pull if possible
        echo "Checking git repository status..."
        if [ -d ".git" ]; then
            echo "Git repository found, pulling latest changes..."
            git pull origin main || git pull origin master || echo "âš ï¸ Git pull failed, continuing with existing code"
        else
            echo "âš ï¸ Not a git repository, skipping git pull"
        fi
        
        # Check and setup virtual environment
        echo "Checking virtual environment..."
        if [ ! -f "venv/bin/activate" ]; then
            echo "âš ï¸ Virtual environment not found, creating new one..."
            python3 -m venv venv
            echo "âœ… Virtual environment created"
        fi
        
        # Activate virtual environment
        echo "Activating virtual environment..."
        source venv/bin/activate
        pip install --upgrade pip
        
        # Install dependencies based on available requirements.txt
        echo "Installing Python dependencies..."
        if [ -f "sample-python-app/requirements.txt" ]; then
            echo "Installing from sample-python-app/requirements.txt..."
            pip install -r sample-python-app/requirements.txt
        elif [ -f "requirements.txt" ]; then
            echo "Installing from requirements.txt..."
            pip install -r requirements.txt
        else
            echo "No requirements.txt found, installing basic dependencies..."
            pip install flask gunicorn psutil
        fi
        
        # Copy application files if sample-python-app directory exists
        if [ -d "sample-python-app" ]; then
            echo "Copying application files from sample-python-app..."
            cp -r sample-python-app/* .
            echo "âœ… Application files copied"
        else
            echo "âš ï¸ sample-python-app directory not found, assuming files are already in place"
        fi
        
        # Test the application
        echo "Testing application import..."
        if python -c "import app; print('âœ… App imports successfully')" 2>/dev/null; then
            echo "âœ… Application import successful"
        else
            echo "âŒ Application import failed, attempting to fix..."
            echo "Current directory contents:"
            ls -la
            
            # Try to find and copy app.py if it exists elsewhere
            if [ -f "sample-python-app/app.py" ]; then
                echo "Found app.py in sample-python-app, copying..."
                cp -r sample-python-app/* .
                echo "Files after copying:"
                ls -la *.py 2>/dev/null || echo "Still no Python files found"
            else
                echo "Searching for app.py in subdirectories..."
                find . -name "app.py" -type f || echo "app.py not found anywhere"
                
                # If still not found, try to re-clone the repository
                echo "Attempting to re-clone repository..."
                cd /home/$(admin_username)
                if [ -d "terraformcode" ]; then
                    echo "Found terraformcode directory, copying files..."
                    cp -r terraformcode/sample-python-app/* \$APP_DIR/ 2>/dev/null || echo "Copy failed"
                fi
                cd \$APP_DIR
            fi
            
            # Test again after attempting fixes
            if python -c "import app; print('âœ… App imports successfully after fix')" 2>/dev/null; then
                echo "âœ… Application import successful after fix"
            else
                echo "âŒ Application import still failed"
                echo "Final directory contents:"
                ls -la
                exit 1
            fi
        fi
        
        # Restart application service
        echo "Restarting application service..."
        if sudo supervisorctl status $APP_NAME >/dev/null 2>&1; then
            echo "Restarting with supervisor..."
            sudo supervisorctl restart $APP_NAME
            sleep 5
            sudo supervisorctl status $APP_NAME
        elif sudo systemctl is-enabled $APP_NAME >/dev/null 2>&1; then
            echo "Restarting with systemctl..."
            sudo systemctl restart $APP_NAME
            sleep 5
            sudo systemctl status $APP_NAME --no-pager -l
        else
            echo "âš ï¸ Service not found in supervisor or systemctl, checking if it's running..."
            ps aux | grep -E "(gunicorn|python.*app)" | grep -v grep || echo "No application process found"
        fi
        
        # Test and reload nginx
        echo "Testing and reloading nginx..."
        sudo nginx -t
        sudo systemctl reload nginx
        
        # Wait for services to stabilize
        sleep 10
        
        # Test application endpoints
        echo "Testing application endpoints..."
        if curl -f -s http://localhost/health >/dev/null 2>&1; then
            echo "âœ… Health endpoint OK"
        else
            echo "âŒ Health endpoint failed"
            echo "Checking if Flask is running on port 5000..."
            curl -f -s http://localhost:5000/health >/dev/null 2>&1 && echo "Flask running on 5000" || echo "Flask not responding on 5000"
        fi
        
        if curl -f -s http://localhost/ >/dev/null 2>&1; then
            echo "âœ… Home page OK"
        else
            echo "âŒ Home page failed"
        fi
        
        echo "âœ… Application deployment completed successfully!"
        EOF
        
        # Copy and execute deployment script on VM
        scp deploy_app.sh $(admin_username)@$VM_IP:/tmp/
        ssh $(admin_username)@$VM_IP "chmod +x /tmp/deploy_app.sh && /tmp/deploy_app.sh"
        
        echo "âœ… Application deployed successfully!"
      displayName: 'Deploy Application'
    
    - script: |
        echo "Performing post-deployment validation..."
        VM_IP="$(vm_public_ip_final)"
        
        # Test application endpoints from outside the VM
        echo "Testing application from external access..."
        
        # Wait for application to be fully ready
        sleep 30
        
        for i in {1..10}; do
          echo "Attempt $i/10: Testing health endpoint..."
          if curl -f -s "http://$VM_IP/health"; then
            echo "âœ… Application is healthy and accessible!"
            break
          else
            echo "â³ Application not ready yet, waiting 30 seconds..."
            sleep 30
          fi
          
          if [ $i -eq 10 ]; then
            echo "âŒ Application failed to respond within 5 minutes"
            # Debug information
            ssh $(admin_username)@$VM_IP "sudo supervisorctl status $(app_name) || sudo systemctl status $(app_name) --no-pager -l"
            ssh $(admin_username)@$VM_IP "sudo systemctl status nginx --no-pager -l"
            ssh $(admin_username)@$VM_IP "sudo tail -20 /var/log/$(app_name).log || echo 'No app logs found'"
            exit 1
          fi
        done
        
        # Test other endpoints
        echo "Testing additional endpoints..."
        curl -f -s "http://$VM_IP/" > /dev/null && echo "âœ… Home page OK" || echo "âŒ Home page failed"
        curl -f -s "http://$VM_IP/api/info" > /dev/null && echo "âœ… API info OK" || echo "âŒ API info failed"
        curl -f -s "http://$VM_IP/api/hello?name=AzureDevOps" > /dev/null && echo "âœ… API hello OK" || echo "âŒ API hello failed"
        
        echo "âœ… All post-deployment validations passed!"
      displayName: 'Validate Deployment'

- stage: 'Validate_Deployment'
  displayName: 'Final Validation and Testing'
  dependsOn: 'Deploy_Application'
  variables:
    vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_public_ip'] ]
    ssh_connection: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.ssh_connection'] ]
    resource_group_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.resource_group_name'] ]
    vm_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_name'] ]
  
  jobs:
  - job: 'TestApplication'
    displayName: 'Test Application and SSH Access'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - script: |
        echo "=== DEBUGGING STAGE DEPENDENCIES ==="
        echo "Available stage dependencies:"
        echo "Deploy stage status: $(stageDependencies.Deploy.result)"
        echo "DeployInfrastructure job status: $(stageDependencies.Deploy.DeployInfrastructure.result)"
        echo
        echo "Checking all available outputs from Deploy.DeployInfrastructure:"
        echo "All outputs keys: $(stageDependencies.Deploy.DeployInfrastructure.outputs)"
        echo
        echo "Trying alternative variable paths:"
        echo "Alternative vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['vm_public_ip'] ]"
        echo "Alternative ssh_connection: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['ssh_connection'] ]"
        echo "======================================="
        
        echo "=== DEBUGGING PIPELINE VARIABLES ==="
        echo "VM Public IP: '$(vm_public_ip)'"
        echo "SSH Connection: '$(ssh_connection)'"
        echo "Resource Group: '$(resource_group_name)'"
        echo "VM Name: '$(vm_name)'"
        echo
        echo "Variable lengths:"
        echo "vm_public_ip length: $(echo '$(vm_public_ip)' | wc -c)"
        echo "ssh_connection length: $(echo '$(ssh_connection)' | wc -c)"
        echo "====================================="
      displayName: 'Debug Stage Variables and Dependencies'
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download SSH Keys'
      inputs:
        buildType: 'current'
        artifactName: 'ssh-keys'
        targetPath: '$(Agent.TempDirectory)/ssh-keys'
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Terraform Outputs (Fallback)'
      inputs:
        buildType: 'current'
        artifactName: 'terraform-outputs'
        targetPath: '$(Agent.TempDirectory)/terraform-outputs'
    
    - script: |
        echo "=== FALLBACK VARIABLE LOADING ==="
        if [ -f "$(Agent.TempDirectory)/terraform-outputs/variables.txt" ]; then
          echo "Loading variables from artifact..."
          cat $(Agent.TempDirectory)/terraform-outputs/variables.txt
          
          # Source the variables if pipeline variables are empty
          if [ -z "$(vm_public_ip)" ] || [ "$(vm_public_ip)" = "" ]; then
            echo "Pipeline variables are empty, loading from artifact..."
            
            # Parse variables more safely (avoid issues with spaces in SSH connection)
            VM_PUBLIC_IP_ARTIFACT=$(grep "^vm_public_ip=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            VM_PRIVATE_IP_ARTIFACT=$(grep "^vm_private_ip=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            SSH_CONNECTION_ARTIFACT=$(grep "^ssh_connection=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            RESOURCE_GROUP_ARTIFACT=$(grep "^resource_group_name=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            VM_NAME_ARTIFACT=$(grep "^vm_name=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            
            echo "Parsed from artifact:"
            echo "VM Public IP: '$VM_PUBLIC_IP_ARTIFACT'"
            echo "SSH Connection: '$SSH_CONNECTION_ARTIFACT'"
            echo "Resource Group: '$RESOURCE_GROUP_ARTIFACT'"
            echo "VM Name: '$VM_NAME_ARTIFACT'"
            
            echo "Setting task variables from artifact:"
            echo "##vso[task.setvariable variable=vm_public_ip_fallback]$VM_PUBLIC_IP_ARTIFACT"
            echo "##vso[task.setvariable variable=ssh_connection_fallback]$SSH_CONNECTION_ARTIFACT"
            echo "##vso[task.setvariable variable=resource_group_name_fallback]$RESOURCE_GROUP_ARTIFACT"
            echo "##vso[task.setvariable variable=vm_name_fallback]$VM_NAME_ARTIFACT"
          else
            echo "Pipeline variables are available, using them..."
          fi
        else
          echo "âŒ ERROR: Terraform outputs artifact not found!"
        fi
        echo "=================================="
      displayName: 'Load Variables from Artifact (if needed)'
    
    - script: |
        echo "=== DEBUGGING PIPELINE VARIABLES ==="
        echo "VM Public IP: '$(vm_public_ip)'"
        echo "SSH Connection: '$(ssh_connection)'"
        echo "Resource Group: '$(resource_group_name)'"
        echo "VM Name: '$(vm_name)'"
        echo "Fallback variables:"
        echo "VM Public IP (fallback): '$(vm_public_ip_fallback)'"
        echo "SSH Connection (fallback): '$(ssh_connection_fallback)'"
        echo "====================================="
        
        # Determine which variables to use
        if [ -n "$(vm_public_ip)" ] && [ "$(vm_public_ip)" != "" ]; then
          VM_IP="$(vm_public_ip)"
          SSH_CONN="$(ssh_connection)"
          echo "âœ… Using pipeline variables"
        elif [ -n "$(vm_public_ip_fallback)" ] && [ "$(vm_public_ip_fallback)" != "" ]; then
          VM_IP="$(vm_public_ip_fallback)"
          # Construct SSH connection from fallback variables if not available
          if [ -n "$(ssh_connection_fallback)" ] && [ "$(ssh_connection_fallback)" != "" ]; then
            SSH_CONN="$(ssh_connection_fallback)"
          else
            # Construct SSH connection using admin username and fallback IP
            SSH_CONN="ssh $(admin_username)@$(vm_public_ip_fallback)"
          fi
          echo "âœ… Using fallback variables from artifact"
        else
          echo "âŒ ERROR: No valid variables found!"
          echo "This indicates the Terraform deployment may have failed."
          echo "Check the previous 'Deploy Infrastructure with Terraform' task for errors."
          exit 1
        fi
        
        echo "âœ… Variables selected successfully"
        echo "Waiting for VM setup to complete..."
        echo "VM Public IP: $VM_IP"
        echo "SSH Connection: $SSH_CONN"
        
        # Store variables for subsequent tasks
        echo "##vso[task.setvariable variable=final_vm_ip]$VM_IP"
        echo "##vso[task.setvariable variable=final_ssh_connection]$SSH_CONN"
        
        # Wait for VM extension to complete setup
        sleep 120
      displayName: 'Wait for VM Setup'
    
    - script: |
        echo "Testing application endpoints..."
        VM_IP="$(final_vm_ip)"
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ ERROR: Final VM IP is not set!"
          exit 1
        fi
        
        echo "Using VM IP: $VM_IP"
        
        # Test application health (with retries)
        for i in {1..20}; do
          echo "Attempt $i/20: Testing health endpoint..."
          if curl -f -s "http://$VM_IP/health"; then
            echo "âœ… Application is healthy!"
            break
          else
            echo "â³ Application not ready yet, waiting 30 seconds..."
            sleep 30
          fi
          
          if [ $i -eq 20 ]; then
            echo "âŒ Application failed to start within 10 minutes"
            exit 1
          fi
        done
        
        echo "Testing other endpoints..."
        
        # Test home page
        echo "Testing home page..."
        curl -f -s "http://$VM_IP/" > /dev/null && echo "âœ… Home page OK" || echo "âŒ Home page failed"
        
        # Test API endpoints
        echo "Testing API endpoints..."
        curl -f -s "http://$VM_IP/api/info" > /dev/null && echo "âœ… API info OK" || echo "âŒ API info failed"
        curl -f -s "http://$VM_IP/api/hello?name=AzureDevOps" > /dev/null && echo "âœ… API hello OK" || echo "âŒ API hello failed"
        
        echo "âœ… All endpoint tests completed!"
      displayName: 'Test Application Endpoints'
    
    - script: |
        echo "Testing SSH access..."
        
        # Setup SSH key
        mkdir -p ~/.ssh
        cp $(Agent.TempDirectory)/ssh-keys/ssh_private_key ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        VM_IP="$(final_vm_ip)"
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ ERROR: Final VM IP is not set for SSH test!"
          exit 1
        fi
        
        echo "Using VM IP for SSH: $VM_IP"
        
        # Add VM to known hosts
        ssh-keyscan -H $VM_IP >> ~/.ssh/known_hosts
        
        # Test SSH connection
        echo "Testing SSH connection to $(admin_username)@$VM_IP..."
        ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no $(admin_username)@$VM_IP "echo 'SSH connection successful!' && hostname && uptime"
        
        # Test application status on VM
        echo "Checking application status on VM..."
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "sudo systemctl status nginx --no-pager -l"
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "sudo supervisorctl status $(app_name)"
        
        echo "âœ… SSH access test completed successfully!"
      displayName: 'Test SSH Access'
    
    - task: AzureCLI@2
      displayName: 'Generate Deployment Summary'
      inputs:
        azureSubscription: $(azureServiceConnection)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          VM_IP="$(final_vm_ip)"
          
          echo "## ðŸš€ Deployment Summary" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### ðŸ“‹ Infrastructure Details" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Resource Group**: $(resource_group_name)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **VM Name**: $(vm_name)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **VM Public IP**: $VM_IP" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Location**: $(location)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### ðŸ”— Application URLs" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Application Home**: http://$VM_IP/" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Health Check**: http://$VM_IP/health" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **System Status**: http://$(vm_public_ip)/status" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **API Info**: http://$(vm_public_ip)/api/info" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### ðŸ”‘ SSH Access" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "```bash" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "ssh $(admin_username)@$(vm_public_ip)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "```" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### ðŸ“Š Pipeline Information" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Build ID**: $(Build.BuildId)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Build Number**: $(Build.BuildNumber)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Source Branch**: $(Build.SourceBranch)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Deployment Time**: $(date)" >> $(Agent.TempDirectory)/deployment_summary.md
          
          echo "Deployment completed successfully! ðŸŽ‰"
          cat $(Agent.TempDirectory)/deployment_summary.md
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Deployment Summary'
      inputs:
        targetPath: '$(Agent.TempDirectory)/deployment_summary.md'
        artifact: 'deployment-summary'
        publishLocation: 'pipeline'

- stage: 'Cleanup'
  displayName: 'Cleanup Resources (Optional)'
  dependsOn: ['Deploy', 'Deploy_Application', 'Validate_Deployment']
  condition: and(succeeded(), eq(variables['cleanup_resources'], 'true'))
  variables:
    resource_group_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.resource_group_name'] ]
  
  jobs:
  - job: 'CleanupInfrastructure'
    displayName: 'Cleanup Azure Resources'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: AzureCLI@2
      displayName: 'Destroy Infrastructure'
      inputs:
        azureSubscription: $(azureServiceConnection)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Starting infrastructure cleanup..."
          echo "Resource Group: $(resource_group_name)"
          
          # Delete the entire resource group (faster than Terraform destroy)
          az group delete --name "$(resource_group_name)" --yes --no-wait
          
          echo "âœ… Cleanup initiated successfully!"!"