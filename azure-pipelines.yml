# Azure DevOps Pipeline for Python Flask App Deployment
# This pipeline creates SSH keys, provisions infrastructure, and deploys the application

trigger:
  branches:
    include:
    - main
    - develop
  paths:
    exclude:
    - README.md
    - docs/*

pr:
  branches:
    include:
    - main

variables:
  # Pipeline Configuration
  terraform_version: '1.5.0'
  python_version: '3.11'
  
  # Azure Service Connection Configuration
  # Service connection 'Ankitdevops' is configured in Azure DevOps
  azureServiceConnection: 'Ankitdevops'
  
  # Application Configuration
  app_name: 'python-flask-app'
  resource_group_prefix: 'rg-flask-app'
  vm_name_prefix: 'vm-flask'
  location: 'East US'
  
  # SSH Configuration
  ssh_key_name: 'flask-app-key'
  admin_username: 'azureuser'

stages:
- stage: 'Validate'
  displayName: 'Validate and Prepare'
  jobs:
  - job: 'ValidateCode'
    displayName: 'Validate Code and Configuration'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: AzureCLI@2
      displayName: 'Install Terraform and Generate SSH Keys'
      inputs:
        azureSubscription: $(azureServiceConnection)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Install Terraform
          echo "Installing Terraform $(terraform_version)..."
          wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
          sudo apt update && sudo apt install terraform
          
          terraform version
          
          echo "Generating SSH key pair..."
          
          # Create .ssh directory if it doesn't exist
          mkdir -p ~/.ssh
          
          # Generate SSH key pair
          ssh-keygen -t rsa -b 4096 -C "$(app_name)-$(Build.BuildId)" -f ~/.ssh/$(ssh_key_name) -N ""
          
          # Read the public key
          SSH_PUBLIC_KEY=$(cat ~/.ssh/$(ssh_key_name).pub)
          SSH_PRIVATE_KEY=$(cat ~/.ssh/$(ssh_key_name))
          
          echo "SSH key pair generated successfully"
          echo "Public key: $SSH_PUBLIC_KEY"
          
          # Set pipeline variables for use in later stages
          echo "##vso[task.setvariable variable=ssh_public_key;isOutput=true;isSecret=false]$SSH_PUBLIC_KEY"
          echo "##vso[task.setvariable variable=ssh_private_key;isOutput=true;isSecret=true]$SSH_PRIVATE_KEY"
          
          # Save keys as pipeline artifacts
          echo "$SSH_PUBLIC_KEY" > $(Agent.TempDirectory)/ssh_public_key.pub
          echo "$SSH_PRIVATE_KEY" > $(Agent.TempDirectory)/ssh_private_key
          
          # Set file permissions
          chmod 600 $(Agent.TempDirectory)/ssh_private_key
          chmod 644 $(Agent.TempDirectory)/ssh_public_key.pub
          
          echo "SSH keys saved to artifacts"
      name: 'PrepareEnvironment'
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish SSH Keys'
      inputs:
        targetPath: '$(Agent.TempDirectory)'
        artifact: 'ssh-keys'
        publishLocation: 'pipeline'
    
    - script: |
        cd terraform
        terraform fmt -check -recursive
        terraform init -backend=false
        terraform validate
      displayName: 'Validate Terraform Configuration'
    
    - task: UsePythonVersion@0
      displayName: 'Setup Python'
      inputs:
        versionSpec: $(python_version)
    
    - script: |
        cd sample-python-app
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        python -m py_compile app.py
      displayName: 'Validate Python Application'

- stage: 'Deploy'
  displayName: 'Deploy Infrastructure and Application'
  dependsOn: 'Validate'
  # Removed branch condition for testing - deploy on any branch
  # condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  variables:
    ssh_public_key: $[ stageDependencies.Validate.ValidateCode.outputs['PrepareEnvironment.ssh_public_key'] ]
    ssh_private_key: $[ stageDependencies.Validate.ValidateCode.outputs['PrepareEnvironment.ssh_private_key'] ]
  
  jobs:
  - deployment: 'DeployInfrastructure'
    displayName: 'Deploy Azure Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    
    strategy:
      runOnce:
        deploy:
          steps:
          - script: |
              echo "=== DEPLOY STAGE DEBUGGING ==="
              echo "Deploy stage is running!"
              echo "Branch: $(Build.SourceBranch)"
              echo "Build ID: $(Build.BuildId)"
              echo "SSH Public Key (first 50 chars): $(echo '$(ssh_public_key)' | cut -c1-50)..."
              echo "SSH Public Key length: $(echo '$(ssh_public_key)' | wc -c)"
              echo "==============================="
            displayName: 'Debug Deploy Stage Variables'
          
          - checkout: self
            displayName: 'Checkout Repository'
          
          - task: DownloadPipelineArtifact@2
            displayName: 'Download SSH Keys'
            inputs:
              buildType: 'current'
              artifactName: 'ssh-keys'
              targetPath: '$(Agent.TempDirectory)/ssh-keys'
          
          - task: AzureCLI@2
            displayName: 'Deploy Infrastructure with Terraform'
            name: 'TerraformDeploy'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e  # Exit on any error
                
                # Install Terraform
                echo "Installing Terraform..."
                wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
                echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
                sudo apt update && sudo apt install terraform
                
                echo "Starting Terraform deployment..."
                
                # Set unique resource names
                UNIQUE_SUFFIX=$(echo $(Build.BuildId) | tail -c 5)
                RESOURCE_GROUP_NAME="$(resource_group_prefix)-$UNIQUE_SUFFIX"
                VM_NAME="$(vm_name_prefix)-$UNIQUE_SUFFIX"
                
                echo "Resource Group: $RESOURCE_GROUP_NAME"
                echo "VM Name: $VM_NAME"
                
                # Debug SSH Key
                echo "=== SSH KEY DEBUGGING ==="
                echo "SSH Public Key (first 50 chars): $(echo '$(ssh_public_key)' | cut -c1-50)..."
                echo "SSH Public Key length: $(echo '$(ssh_public_key)' | wc -c)"
                
                if [ -z "$(ssh_public_key)" ]; then
                  echo "❌ ERROR: SSH Public Key is empty!"
                  echo "This will cause Terraform to fail."
                  exit 1
                fi
                echo "✅ SSH Public Key is present"
                echo "========================="
                
                # Debug: Show Azure context
                echo "Azure CLI context:"
                az account show
                
                cd terraform
                
                # Initialize Terraform
                echo "Initializing Terraform..."
                terraform init
                
                # Plan deployment
                echo "Planning Terraform deployment..."
                terraform plan \
                  -var="resource_group_name=$RESOURCE_GROUP_NAME" \
                  -var="location=$(location)" \
                  -var="vm_name=$VM_NAME" \
                  -var="admin_username=$(admin_username)" \
                  -var="admin_ssh_key=$(ssh_public_key)" \
                  -var="github_repo_url=$(Build.Repository.Uri)" \
                  -var="app_name=$(app_name)" \
                  -var="github_token=" \
                  -out=tfplan
                
                # Apply deployment
                echo "Applying Terraform deployment..."
                if terraform apply -auto-approve tfplan; then
                  echo "✅ Terraform apply completed successfully"
                else
                  echo "❌ Terraform apply failed!"
                  echo "Terraform state:"
                  terraform show || echo "No state to show"
                  echo "Terraform output:"
                  terraform output || echo "No outputs available"
                  exit 1
                fi
                
                # Verify deployment and state before getting outputs
                echo "=== VERIFYING TERRAFORM DEPLOYMENT ==="
                echo "Checking Terraform state..."
                if ! terraform show >/dev/null 2>&1; then
                  echo "❌ ERROR: Terraform state is invalid or empty!"
                  exit 1
                fi
                
                echo "Checking if outputs are available..."
                if ! terraform output >/dev/null 2>&1; then
                  echo "❌ ERROR: No Terraform outputs available!"
                  echo "This usually means the apply didn't complete successfully."
                  exit 1
                fi
                
                echo "✅ Terraform state and outputs are available"
                echo "========================================"
                
                # Get outputs with error checking and fallbacks
                echo "Getting Terraform outputs..."
                
                # Show all outputs first for debugging
                echo "=== ALL TERRAFORM OUTPUTS (JSON) ==="
                terraform output -json
                echo "=== ALL TERRAFORM OUTPUTS (READABLE) ==="
                terraform output
                echo "===================================="
                
                # Verify Terraform state
                echo "=== TERRAFORM STATE VERIFICATION ==="
                terraform show -json | jq '.values.outputs' 2>/dev/null || echo "No outputs found in state"
                echo "===================================="
                
                # Get VM public IP with enhanced debugging
                echo "=== GETTING VM PUBLIC IP ==="
                echo "Attempting to get vm_public_ip output..."
                VM_PUBLIC_IP=$(terraform output -raw vm_public_ip 2>&1)
                echo "Raw output: '$VM_PUBLIC_IP'"
                
                if [ -n "$VM_PUBLIC_IP" ] && [ "$VM_PUBLIC_IP" != "null" ] && [ "$VM_PUBLIC_IP" != "Error"* ]; then
                  echo "✅ VM Public IP from Terraform: $VM_PUBLIC_IP"
                else
                  echo "❌ WARNING: vm_public_ip output not valid: '$VM_PUBLIC_IP'"
                  echo "Attempting Azure CLI fallback..."
                  
                  # List all public IPs in the resource group for debugging
                  echo "All public IPs in resource group $RESOURCE_GROUP_NAME:"
                  az network public-ip list --resource-group "$RESOURCE_GROUP_NAME" --query "[].{Name:name, IP:ipAddress, Status:provisioningState}" --output table
                  
                  # Try the expected public IP name
                  EXPECTED_PIP_NAME="${VM_NAME}-pip"
                  echo "Looking for public IP: $EXPECTED_PIP_NAME"
                  VM_PUBLIC_IP=$(az network public-ip show --resource-group "$RESOURCE_GROUP_NAME" --name "$EXPECTED_PIP_NAME" --query ipAddress --output tsv 2>/dev/null || echo "")
                  
                  if [ -n "$VM_PUBLIC_IP" ] && [ "$VM_PUBLIC_IP" != "null" ]; then
                    echo "✅ VM Public IP from Azure CLI: $VM_PUBLIC_IP"
                  else
                    echo "❌ ERROR: Could not get VM public IP from Azure CLI either"
                    echo "Checking if public IP resource exists..."
                    az network public-ip show --resource-group "$RESOURCE_GROUP_NAME" --name "$EXPECTED_PIP_NAME" 2>&1 || echo "Public IP resource not found"
                    
                    # Final attempt: Check all public IPs and their allocation status
                    echo "=== DETAILED PUBLIC IP DIAGNOSIS ==="
                    az network public-ip list --resource-group "$RESOURCE_GROUP_NAME" --output json | jq -r '.[] | "\(.name): \(.ipAddress // "Not Allocated") (\(.publicIPAllocationMethod)) - \(.provisioningState)"'
                    echo "===================================="
                    exit 1
                  fi
                fi
                echo "=========================="
                
                # Validate that we have a proper IP address
                echo "=== VALIDATING IP ADDRESS ==="
                if [[ $VM_PUBLIC_IP =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
                  echo "✅ Valid IP address format: $VM_PUBLIC_IP"
                else
                  echo "❌ ERROR: Invalid IP address format: '$VM_PUBLIC_IP'"
                  echo "Expected format: xxx.xxx.xxx.xxx"
                  exit 1
                fi
                echo "=========================="
                
                # Get VM private IP with enhanced debugging
                echo "=== GETTING VM PRIVATE IP ==="
                echo "Attempting to get vm_private_ip output..."
                VM_PRIVATE_IP=$(terraform output -raw vm_private_ip 2>&1)
                echo "Raw output: '$VM_PRIVATE_IP'"
                
                if [ -n "$VM_PRIVATE_IP" ] && [ "$VM_PRIVATE_IP" != "null" ] && [ "$VM_PRIVATE_IP" != "Error"* ]; then
                  echo "✅ VM Private IP: $VM_PRIVATE_IP"
                else
                  echo "❌ WARNING: vm_private_ip output not valid: '$VM_PRIVATE_IP'"
                  echo "Setting to empty for now"
                  VM_PRIVATE_IP=""
                fi
                echo "=========================="
                
                # Generate SSH connection string
                if [ -n "$VM_PUBLIC_IP" ]; then
                  SSH_CONNECTION="ssh $(admin_username)@$VM_PUBLIC_IP"
                  echo "✅ SSH Connection: $SSH_CONNECTION"
                else
                  echo "❌ ERROR: Cannot generate SSH connection without public IP"
                  exit 1
                fi
                
                # Set pipeline variables
                echo "Setting pipeline variables..."
                echo "##vso[task.setvariable variable=vm_public_ip;isOutput=true]$VM_PUBLIC_IP"
                echo "##vso[task.setvariable variable=vm_private_ip;isOutput=true]$VM_PRIVATE_IP"
                echo "##vso[task.setvariable variable=ssh_connection;isOutput=true]$SSH_CONNECTION"
                echo "##vso[task.setvariable variable=resource_group_name;isOutput=true]$RESOURCE_GROUP_NAME"
                echo "##vso[task.setvariable variable=vm_name;isOutput=true]$VM_NAME"
                
                # Create artifact with variables as fallback
                echo "Creating variables artifact..."
                mkdir -p $(Agent.TempDirectory)/terraform-outputs
                echo "vm_public_ip=$VM_PUBLIC_IP" > $(Agent.TempDirectory)/terraform-outputs/variables.txt
                echo "vm_private_ip=$VM_PRIVATE_IP" >> $(Agent.TempDirectory)/terraform-outputs/variables.txt
                echo "ssh_connection=$SSH_CONNECTION" >> $(Agent.TempDirectory)/terraform-outputs/variables.txt
                echo "resource_group_name=$RESOURCE_GROUP_NAME" >> $(Agent.TempDirectory)/terraform-outputs/variables.txt
                echo "vm_name=$VM_NAME" >> $(Agent.TempDirectory)/terraform-outputs/variables.txt
                echo "Generated variables file:"
                cat $(Agent.TempDirectory)/terraform-outputs/variables.txt
                
                # Verify variables were set
                echo "=== VERIFYING PIPELINE VARIABLES ==="
                echo "vm_public_ip: $VM_PUBLIC_IP"
                echo "vm_private_ip: $VM_PRIVATE_IP"
                echo "ssh_connection: $SSH_CONNECTION"
                echo "resource_group_name: $RESOURCE_GROUP_NAME"
                echo "vm_name: $VM_NAME"
                echo "===================================="
                
                echo "Infrastructure deployed successfully!"
                echo "VM Public IP: $VM_PUBLIC_IP"
                echo "SSH Connection: $SSH_CONNECTION"

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Terraform Outputs'
            inputs:
              targetPath: '$(Agent.TempDirectory)/terraform-outputs'
              artifact: 'terraform-outputs'

- stage: 'Deploy_Application'
  displayName: 'Deploy Application to VM'
  dependsOn: 'Deploy'
  variables:
    vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_public_ip'] ]
    ssh_connection: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.ssh_connection'] ]
    resource_group_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.resource_group_name'] ]
    vm_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_name'] ]
  
  jobs:
  - job: 'DeployToVM'
    displayName: 'Deploy Application via SSH'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download SSH Keys'
      inputs:
        buildType: 'current'
        artifactName: 'ssh-keys'
        targetPath: '$(Agent.TempDirectory)/ssh-keys'
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Terraform Outputs (Fallback)'
      inputs:
        buildType: 'current'
        artifactName: 'terraform-outputs'
        targetPath: '$(Agent.TempDirectory)/terraform-outputs'
    
    - script: |
        echo "=== APPLICATION DEPLOYMENT STAGE ==="
        echo "VM Public IP: '$(vm_public_ip)'"
        echo "SSH Connection: '$(ssh_connection)'"
        echo "Resource Group: '$(resource_group_name)'"
        echo "VM Name: '$(vm_name)'"
        echo "===================================="
        
        # Load variables from artifact if pipeline variables are empty
        if [ -z "$(vm_public_ip)" ] || [ "$(vm_public_ip)" = "" ]; then
          echo "Loading variables from artifact..."
          if [ -f "$(Agent.TempDirectory)/terraform-outputs/variables.txt" ]; then
            VM_PUBLIC_IP_ARTIFACT=$(grep "^vm_public_ip=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            echo "##vso[task.setvariable variable=vm_public_ip_final]$VM_PUBLIC_IP_ARTIFACT"
          fi
        else
          echo "##vso[task.setvariable variable=vm_public_ip_final]$(vm_public_ip)"
        fi
        
        echo "Final VM IP: $(vm_public_ip_final)"
      displayName: 'Prepare Deployment Variables'
    
    - script: |
        echo "Setting up SSH connection..."
        
        # Setup SSH key
        mkdir -p ~/.ssh
        cp $(Agent.TempDirectory)/ssh-keys/ssh_private_key ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        VM_IP="$(vm_public_ip_final)"
        
        if [ -z "$VM_IP" ]; then
          echo "❌ ERROR: VM IP is not available!"
          exit 1
        fi
        
        echo "Using VM IP: $VM_IP"
        
        # Add VM to known hosts
        ssh-keyscan -H $VM_IP >> ~/.ssh/known_hosts
        
        # Test SSH connection
        echo "Testing SSH connection..."
        ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no $(admin_username)@$VM_IP "echo 'SSH connection successful!' && hostname"
        
        echo "✅ SSH connection established successfully!"
      displayName: 'Setup SSH Connection'
    
    - script: |
        echo "Waiting for VM initialization to complete..."
        VM_IP="$(vm_public_ip_final)"
        
        # Wait for the VM extension script to complete (nginx installation)
        echo "Checking if nginx is installed and running..."
        for i in {1..30}; do
          echo "Attempt $i/30: Checking nginx status..."
          if ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "sudo systemctl is-active nginx >/dev/null 2>&1"; then
            echo "✅ Nginx is running!"
            break
          else
            echo "⏳ Nginx not ready yet, waiting 30 seconds..."
            sleep 30
          fi
          
          if [ $i -eq 30 ]; then
            echo "❌ Nginx failed to start within 15 minutes"
            echo "Checking nginx status..."
            ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "sudo systemctl status nginx --no-pager -l" || true
            exit 1
          fi
        done
        
        echo "✅ VM is ready for application deployment!"
      displayName: 'Wait for VM Initialization'
    
    - script: |
        echo "Checking VM setup status before deployment..."
        VM_IP="$(vm_public_ip_final)"
        
        # Check VM setup status
        echo "Verifying VM setup completion..."
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "echo 'SSH connection working'"
        
        # Check if setup log exists and show recent entries
        echo "Checking setup log..."
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "tail -10 /var/log/app-setup.log 2>/dev/null || echo 'Setup log not found'"
        
        # Check basic services
        echo "Checking basic services..."
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "sudo systemctl is-active nginx && echo 'Nginx is active' || echo 'Nginx is not active'"
        
        echo "VM status check completed, proceeding with deployment..."
      displayName: 'Check VM Status'
    
    - script: |
        echo "Deploying application to VM..."
        VM_IP="$(vm_public_ip_final)"
        
        # Create deployment script
        cat > deploy_app.sh << 'EOF'
        #!/bin/bash
        set -e
        
        APP_NAME="${app_name}"
        APP_DIR="/home/$(admin_username)/$APP_NAME"
        
        echo "=== APPLICATION DEPLOYMENT ==="
        echo "App Name: $APP_NAME"
        echo "App Directory: $APP_DIR"
        echo "Current User: $(whoami)"
        echo "=============================="
        
        # Check if app directory exists
        if [ ! -d "$APP_DIR" ]; then
            echo "❌ ERROR: Application directory not found: $APP_DIR"
            echo "Available directories in /home/$(admin_username):"
            ls -la /home/$(admin_username)/
            exit 1
        fi
        
        # Navigate to app directory
        cd $APP_DIR
        echo "Current directory: $(pwd)"
        echo "Directory contents:"
        ls -la
        
        # Check if this is a git repository and pull if possible
        echo "Checking git repository status..."
        if [ -d ".git" ]; then
            echo "Git repository found, pulling latest changes..."
            git pull origin main || git pull origin master || echo "⚠️ Git pull failed, continuing with existing code"
        else
            echo "⚠️ Not a git repository, skipping git pull"
        fi
        
        # Check and setup virtual environment
        echo "Checking virtual environment..."
        if [ ! -f "venv/bin/activate" ]; then
            echo "⚠️ Virtual environment not found, creating new one..."
            python3 -m venv venv
            echo "✅ Virtual environment created"
        fi
        
        # Activate virtual environment
        echo "Activating virtual environment..."
        source venv/bin/activate
        pip install --upgrade pip
        
        # Install dependencies based on available requirements.txt
        echo "Installing Python dependencies..."
        if [ -f "sample-python-app/requirements.txt" ]; then
            echo "Installing from sample-python-app/requirements.txt..."
            pip install -r sample-python-app/requirements.txt
        elif [ -f "requirements.txt" ]; then
            echo "Installing from requirements.txt..."
            pip install -r requirements.txt
        else
            echo "No requirements.txt found, installing basic dependencies..."
            pip install flask gunicorn psutil
        fi
        
        # Copy application files if sample-python-app directory exists
        if [ -d "sample-python-app" ]; then
            echo "Copying application files from sample-python-app..."
            cp -r sample-python-app/* .
            echo "✅ Application files copied"
        else
            echo "⚠️ sample-python-app directory not found, assuming files are already in place"
        fi
        
        # Test the application
        echo "Testing application import..."
        if python -c "import app; print('✅ App imports successfully')" 2>/dev/null; then
            echo "✅ Application import successful"
        else
            echo "❌ Application import failed, attempting to fix..."
            echo "Current directory contents:"
            ls -la
            
            # Try to find and copy app.py if it exists elsewhere
            if [ -f "sample-python-app/app.py" ]; then
                echo "Found app.py in sample-python-app, copying..."
                cp -r sample-python-app/* .
                echo "Files after copying:"
                ls -la *.py 2>/dev/null || echo "Still no Python files found"
            else
                echo "Searching for app.py in subdirectories..."
                find . -name "app.py" -type f || echo "app.py not found anywhere"
                
                # If still not found, try to re-clone the repository
                echo "Attempting to re-clone repository..."
                cd /home/$(admin_username)
                if [ -d "terraformcode" ]; then
                    echo "Found terraformcode directory, copying files..."
                    cp -r terraformcode/sample-python-app/* \$APP_DIR/ 2>/dev/null || echo "Copy failed"
                fi
                cd \$APP_DIR
            fi
            
            # Test again after attempting fixes
            if python -c "import app; print('✅ App imports successfully after fix')" 2>/dev/null; then
                echo "✅ Application import successful after fix"
            else
                echo "❌ Application import still failed"
                echo "Final directory contents:"
                ls -la
                exit 1
            fi
        fi
        
        # Restart application service
        echo "Restarting application service..."
        if sudo supervisorctl status $APP_NAME >/dev/null 2>&1; then
            echo "Restarting with supervisor..."
            sudo supervisorctl restart $APP_NAME
            sleep 5
            sudo supervisorctl status $APP_NAME
        elif sudo systemctl is-enabled $APP_NAME >/dev/null 2>&1; then
            echo "Restarting with systemctl..."
            sudo systemctl restart $APP_NAME
            sleep 5
            sudo systemctl status $APP_NAME --no-pager -l
        else
            echo "⚠️ Service not found in supervisor or systemctl, checking if it's running..."
            ps aux | grep -E "(gunicorn|python.*app)" | grep -v grep || echo "No application process found"
        fi
        
        # Test and reload nginx
        echo "Testing and reloading nginx..."
        sudo nginx -t
        sudo systemctl reload nginx
        
        # Wait for services to stabilize
        sleep 10
        
        # Test application endpoints
        echo "Testing application endpoints..."
        if curl -f -s http://localhost/health >/dev/null 2>&1; then
            echo "✅ Health endpoint OK"
        else
            echo "❌ Health endpoint failed"
            echo "Checking if Flask is running on port 5000..."
            curl -f -s http://localhost:5000/health >/dev/null 2>&1 && echo "Flask running on 5000" || echo "Flask not responding on 5000"
        fi
        
        if curl -f -s http://localhost/ >/dev/null 2>&1; then
            echo "✅ Home page OK"
        else
            echo "❌ Home page failed"
        fi
        
        echo "✅ Application deployment completed successfully!"
        EOF
        
        # Copy and execute deployment script on VM
        scp deploy_app.sh $(admin_username)@$VM_IP:/tmp/
        ssh $(admin_username)@$VM_IP "chmod +x /tmp/deploy_app.sh && /tmp/deploy_app.sh"
        
        echo "✅ Application deployed successfully!"
      displayName: 'Deploy Application'
    
    - script: |
        echo "Performing post-deployment validation..."
        VM_IP="$(vm_public_ip_final)"
        
        # Test application endpoints from outside the VM
        echo "Testing application from external access..."
        
        # Wait for application to be fully ready
        sleep 30
        
        for i in {1..10}; do
          echo "Attempt $i/10: Testing health endpoint..."
          if curl -f -s "http://$VM_IP/health"; then
            echo "✅ Application is healthy and accessible!"
            break
          else
            echo "⏳ Application not ready yet, waiting 30 seconds..."
            sleep 30
          fi
          
          if [ $i -eq 10 ]; then
            echo "❌ Application failed to respond within 5 minutes"
            # Debug information
            ssh $(admin_username)@$VM_IP "sudo supervisorctl status $(app_name) || sudo systemctl status $(app_name) --no-pager -l"
            ssh $(admin_username)@$VM_IP "sudo systemctl status nginx --no-pager -l"
            ssh $(admin_username)@$VM_IP "sudo tail -20 /var/log/$(app_name).log || echo 'No app logs found'"
            exit 1
          fi
        done
        
        # Test other endpoints
        echo "Testing additional endpoints..."
        curl -f -s "http://$VM_IP/" > /dev/null && echo "✅ Home page OK" || echo "❌ Home page failed"
        curl -f -s "http://$VM_IP/api/info" > /dev/null && echo "✅ API info OK" || echo "❌ API info failed"
        curl -f -s "http://$VM_IP/api/hello?name=AzureDevOps" > /dev/null && echo "✅ API hello OK" || echo "❌ API hello failed"
        
        echo "✅ All post-deployment validations passed!"
      displayName: 'Validate Deployment'

- stage: 'Validate_Deployment'
  displayName: 'Final Validation and Testing'
  dependsOn: 'Deploy_Application'
  variables:
    vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_public_ip'] ]
    ssh_connection: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.ssh_connection'] ]
    resource_group_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.resource_group_name'] ]
    vm_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_name'] ]
  
  jobs:
  - job: 'TestApplication'
    displayName: 'Test Application and SSH Access'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - script: |
        echo "=== DEBUGGING STAGE DEPENDENCIES ==="
        echo "Available stage dependencies:"
        echo "Deploy stage status: $(stageDependencies.Deploy.result)"
        echo "DeployInfrastructure job status: $(stageDependencies.Deploy.DeployInfrastructure.result)"
        echo
        echo "Checking all available outputs from Deploy.DeployInfrastructure:"
        echo "All outputs keys: $(stageDependencies.Deploy.DeployInfrastructure.outputs)"
        echo
        echo "Trying alternative variable paths:"
        echo "Alternative vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['vm_public_ip'] ]"
        echo "Alternative ssh_connection: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['ssh_connection'] ]"
        echo "======================================="
        
        echo "=== DEBUGGING PIPELINE VARIABLES ==="
        echo "VM Public IP: '$(vm_public_ip)'"
        echo "SSH Connection: '$(ssh_connection)'"
        echo "Resource Group: '$(resource_group_name)'"
        echo "VM Name: '$(vm_name)'"
        echo
        echo "Variable lengths:"
        echo "vm_public_ip length: $(echo '$(vm_public_ip)' | wc -c)"
        echo "ssh_connection length: $(echo '$(ssh_connection)' | wc -c)"
        echo "====================================="
      displayName: 'Debug Stage Variables and Dependencies'
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download SSH Keys'
      inputs:
        buildType: 'current'
        artifactName: 'ssh-keys'
        targetPath: '$(Agent.TempDirectory)/ssh-keys'
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Terraform Outputs (Fallback)'
      inputs:
        buildType: 'current'
        artifactName: 'terraform-outputs'
        targetPath: '$(Agent.TempDirectory)/terraform-outputs'
    
    - script: |
        echo "=== FALLBACK VARIABLE LOADING ==="
        if [ -f "$(Agent.TempDirectory)/terraform-outputs/variables.txt" ]; then
          echo "Loading variables from artifact..."
          cat $(Agent.TempDirectory)/terraform-outputs/variables.txt
          
          # Source the variables if pipeline variables are empty
          if [ -z "$(vm_public_ip)" ] || [ "$(vm_public_ip)" = "" ]; then
            echo "Pipeline variables are empty, loading from artifact..."
            
            # Parse variables more safely (avoid issues with spaces in SSH connection)
            VM_PUBLIC_IP_ARTIFACT=$(grep "^vm_public_ip=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            VM_PRIVATE_IP_ARTIFACT=$(grep "^vm_private_ip=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            SSH_CONNECTION_ARTIFACT=$(grep "^ssh_connection=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            RESOURCE_GROUP_ARTIFACT=$(grep "^resource_group_name=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            VM_NAME_ARTIFACT=$(grep "^vm_name=" $(Agent.TempDirectory)/terraform-outputs/variables.txt | cut -d'=' -f2-)
            
            echo "Parsed from artifact:"
            echo "VM Public IP: '$VM_PUBLIC_IP_ARTIFACT'"
            echo "SSH Connection: '$SSH_CONNECTION_ARTIFACT'"
            echo "Resource Group: '$RESOURCE_GROUP_ARTIFACT'"
            echo "VM Name: '$VM_NAME_ARTIFACT'"
            
            echo "Setting task variables from artifact:"
            echo "##vso[task.setvariable variable=vm_public_ip_fallback]$VM_PUBLIC_IP_ARTIFACT"
            echo "##vso[task.setvariable variable=ssh_connection_fallback]$SSH_CONNECTION_ARTIFACT"
            echo "##vso[task.setvariable variable=resource_group_name_fallback]$RESOURCE_GROUP_ARTIFACT"
            echo "##vso[task.setvariable variable=vm_name_fallback]$VM_NAME_ARTIFACT"
          else
            echo "Pipeline variables are available, using them..."
          fi
        else
          echo "❌ ERROR: Terraform outputs artifact not found!"
        fi
        echo "=================================="
      displayName: 'Load Variables from Artifact (if needed)'
    
    - script: |
        echo "=== DEBUGGING PIPELINE VARIABLES ==="
        echo "VM Public IP: '$(vm_public_ip)'"
        echo "SSH Connection: '$(ssh_connection)'"
        echo "Resource Group: '$(resource_group_name)'"
        echo "VM Name: '$(vm_name)'"
        echo "Fallback variables:"
        echo "VM Public IP (fallback): '$(vm_public_ip_fallback)'"
        echo "SSH Connection (fallback): '$(ssh_connection_fallback)'"
        echo "====================================="
        
        # Determine which variables to use
        if [ -n "$(vm_public_ip)" ] && [ "$(vm_public_ip)" != "" ]; then
          VM_IP="$(vm_public_ip)"
          SSH_CONN="$(ssh_connection)"
          echo "✅ Using pipeline variables"
        elif [ -n "$(vm_public_ip_fallback)" ] && [ "$(vm_public_ip_fallback)" != "" ]; then
          VM_IP="$(vm_public_ip_fallback)"
          # Construct SSH connection from fallback variables if not available
          if [ -n "$(ssh_connection_fallback)" ] && [ "$(ssh_connection_fallback)" != "" ]; then
            SSH_CONN="$(ssh_connection_fallback)"
          else
            # Construct SSH connection using admin username and fallback IP
            SSH_CONN="ssh $(admin_username)@$(vm_public_ip_fallback)"
          fi
          echo "✅ Using fallback variables from artifact"
        else
          echo "❌ ERROR: No valid variables found!"
          echo "This indicates the Terraform deployment may have failed."
          echo "Check the previous 'Deploy Infrastructure with Terraform' task for errors."
          exit 1
        fi
        
        echo "✅ Variables selected successfully"
        echo "Waiting for VM setup to complete..."
        echo "VM Public IP: $VM_IP"
        echo "SSH Connection: $SSH_CONN"
        
        # Store variables for subsequent tasks
        echo "##vso[task.setvariable variable=final_vm_ip]$VM_IP"
        echo "##vso[task.setvariable variable=final_ssh_connection]$SSH_CONN"
        
        # Wait for VM extension to complete setup
        sleep 120
      displayName: 'Wait for VM Setup'
    
    - script: |
        echo "Testing application endpoints..."
        VM_IP="$(final_vm_ip)"
        
        if [ -z "$VM_IP" ]; then
          echo "❌ ERROR: Final VM IP is not set!"
          exit 1
        fi
        
        echo "Using VM IP: $VM_IP"
        
        # Test application health (with retries)
        for i in {1..20}; do
          echo "Attempt $i/20: Testing health endpoint..."
          if curl -f -s "http://$VM_IP/health"; then
            echo "✅ Application is healthy!"
            break
          else
            echo "⏳ Application not ready yet, waiting 30 seconds..."
            sleep 30
          fi
          
          if [ $i -eq 20 ]; then
            echo "❌ Application failed to start within 10 minutes"
            exit 1
          fi
        done
        
        echo "Testing other endpoints..."
        
        # Test home page
        echo "Testing home page..."
        curl -f -s "http://$VM_IP/" > /dev/null && echo "✅ Home page OK" || echo "❌ Home page failed"
        
        # Test API endpoints
        echo "Testing API endpoints..."
        curl -f -s "http://$VM_IP/api/info" > /dev/null && echo "✅ API info OK" || echo "❌ API info failed"
        curl -f -s "http://$VM_IP/api/hello?name=AzureDevOps" > /dev/null && echo "✅ API hello OK" || echo "❌ API hello failed"
        
        echo "✅ All endpoint tests completed!"
      displayName: 'Test Application Endpoints'
    
    - script: |
        echo "Testing SSH access..."
        
        # Setup SSH key
        mkdir -p ~/.ssh
        cp $(Agent.TempDirectory)/ssh-keys/ssh_private_key ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        VM_IP="$(final_vm_ip)"
        
        if [ -z "$VM_IP" ]; then
          echo "❌ ERROR: Final VM IP is not set for SSH test!"
          exit 1
        fi
        
        echo "Using VM IP for SSH: $VM_IP"
        
        # Add VM to known hosts
        ssh-keyscan -H $VM_IP >> ~/.ssh/known_hosts
        
        # Test SSH connection
        echo "Testing SSH connection to $(admin_username)@$VM_IP..."
        ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no $(admin_username)@$VM_IP "echo 'SSH connection successful!' && hostname && uptime"
        
        # Test application status on VM
        echo "Checking application status on VM..."
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "sudo systemctl status nginx --no-pager -l"
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "sudo supervisorctl status $(app_name)"
        
        echo "✅ SSH access test completed successfully!"
      displayName: 'Test SSH Access'
    
    - task: AzureCLI@2
      displayName: 'Generate Deployment Summary'
      inputs:
        azureSubscription: $(azureServiceConnection)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          VM_IP="$(final_vm_ip)"
          
          echo "## 🚀 Deployment Summary" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### 📋 Infrastructure Details" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Resource Group**: $(resource_group_name)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **VM Name**: $(vm_name)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **VM Public IP**: $VM_IP" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Location**: $(location)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### 🔗 Application URLs" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Application Home**: http://$VM_IP/" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Health Check**: http://$VM_IP/health" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **System Status**: http://$(vm_public_ip)/status" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **API Info**: http://$(vm_public_ip)/api/info" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### 🔑 SSH Access" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "```bash" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "ssh $(admin_username)@$(vm_public_ip)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "```" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### 📊 Pipeline Information" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Build ID**: $(Build.BuildId)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Build Number**: $(Build.BuildNumber)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Source Branch**: $(Build.SourceBranch)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Deployment Time**: $(date)" >> $(Agent.TempDirectory)/deployment_summary.md
          
          echo "Deployment completed successfully! 🎉"
          cat $(Agent.TempDirectory)/deployment_summary.md
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Deployment Summary'
      inputs:
        targetPath: '$(Agent.TempDirectory)/deployment_summary.md'
        artifact: 'deployment-summary'
        publishLocation: 'pipeline'

- stage: 'Cleanup'
  displayName: 'Cleanup Resources (Optional)'
  dependsOn: ['Deploy', 'Deploy_Application', 'Validate_Deployment']
  condition: and(succeeded(), eq(variables['cleanup_resources'], 'true'))
  variables:
    resource_group_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.resource_group_name'] ]
  
  jobs:
  - job: 'CleanupInfrastructure'
    displayName: 'Cleanup Azure Resources'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: AzureCLI@2
      displayName: 'Destroy Infrastructure'
      inputs:
        azureSubscription: $(azureServiceConnection)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Starting infrastructure cleanup..."
          echo "Resource Group: $(resource_group_name)"
          
          # Delete the entire resource group (faster than Terraform destroy)
          az group delete --name "$(resource_group_name)" --yes --no-wait
          
          echo "✅ Cleanup initiated successfully!"!"