# Azure DevOps Pipeline for Python Flask App Deployment
# This pipeline creates SSH keys, provisions infrastructure, and deploys the application

trigger:
  branches:
    include:
    - main
    - develop
  paths:
    exclude:
    - README.md
    - docs/*

pr:
  branches:
    include:
    - main

variables:
  # Pipeline Configuration
  terraform_version: '1.5.0'
  python_version: '3.11'
  
  # Azure Service Connection Configuration
  # Service connection 'Ankitdevops' is configured in Azure DevOps
  azureServiceConnection: 'Ankitdevops'
  
  # Application Configuration
  app_name: 'python-flask-app'
  resource_group_prefix: 'rg-flask-app'
  vm_name_prefix: 'vm-flask'
  location: 'East US'
  
  # SSH Configuration
  ssh_key_name: 'flask-app-key'
  admin_username: 'azureuser'

stages:
- stage: 'Validate'
  displayName: 'Validate and Prepare'
  jobs:
  - job: 'ValidateCode'
    displayName: 'Validate Code and Configuration'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: AzureCLI@2
      displayName: 'Install Terraform and Generate SSH Keys'
      inputs:
        azureSubscription: $(azureServiceConnection)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Install Terraform
          echo "Installing Terraform $(terraform_version)..."
          wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
          sudo apt update && sudo apt install terraform
          
          terraform version
          
          echo "Generating SSH key pair..."
          
          # Create .ssh directory if it doesn't exist
          mkdir -p ~/.ssh
          
          # Generate SSH key pair
          ssh-keygen -t rsa -b 4096 -C "$(app_name)-$(Build.BuildId)" -f ~/.ssh/$(ssh_key_name) -N ""
          
          # Read the public key
          SSH_PUBLIC_KEY=$(cat ~/.ssh/$(ssh_key_name).pub)
          SSH_PRIVATE_KEY=$(cat ~/.ssh/$(ssh_key_name))
          
          echo "SSH key pair generated successfully"
          echo "Public key: $SSH_PUBLIC_KEY"
          
          # Set pipeline variables for use in later stages
          echo "##vso[task.setvariable variable=ssh_public_key;isOutput=true;isSecret=false]$SSH_PUBLIC_KEY"
          echo "##vso[task.setvariable variable=ssh_private_key;isOutput=true;isSecret=true]$SSH_PRIVATE_KEY"
          
          # Save keys as pipeline artifacts
          echo "$SSH_PUBLIC_KEY" > $(Agent.TempDirectory)/ssh_public_key.pub
          echo "$SSH_PRIVATE_KEY" > $(Agent.TempDirectory)/ssh_private_key
          
          # Set file permissions
          chmod 600 $(Agent.TempDirectory)/ssh_private_key
          chmod 644 $(Agent.TempDirectory)/ssh_public_key.pub
          
          echo "SSH keys saved to artifacts"
      name: 'PrepareEnvironment'
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish SSH Keys'
      inputs:
        targetPath: '$(Agent.TempDirectory)'
        artifact: 'ssh-keys'
        publishLocation: 'pipeline'
    
    - script: |
        cd terraform
        terraform fmt -check -recursive
        terraform init -backend=false
        terraform validate
      displayName: 'Validate Terraform Configuration'
    
    - task: UsePythonVersion@0
      displayName: 'Setup Python'
      inputs:
        versionSpec: $(python_version)
    
    - script: |
        cd sample-python-app
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        python -m py_compile app.py
      displayName: 'Validate Python Application'

- stage: 'Deploy'
  displayName: 'Deploy Infrastructure and Application'
  dependsOn: 'Validate'
  # Removed branch condition for testing - deploy on any branch
  # condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  variables:
    ssh_public_key: $[ stageDependencies.Validate.ValidateCode.outputs['PrepareEnvironment.ssh_public_key'] ]
    ssh_private_key: $[ stageDependencies.Validate.ValidateCode.outputs['PrepareEnvironment.ssh_private_key'] ]
  
  jobs:
  - deployment: 'DeployInfrastructure'
    displayName: 'Deploy Azure Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    
    strategy:
      runOnce:
        deploy:
          steps:
          - script: |
              echo "=== DEPLOY STAGE DEBUGGING ==="
              echo "Deploy stage is running!"
              echo "Branch: $(Build.SourceBranch)"
              echo "Build ID: $(Build.BuildId)"
              echo "SSH Public Key (first 50 chars): $(echo '$(ssh_public_key)' | cut -c1-50)..."
              echo "SSH Public Key length: $(echo '$(ssh_public_key)' | wc -c)"
              echo "==============================="
            displayName: 'Debug Deploy Stage Variables'
          
          - checkout: self
            displayName: 'Checkout Repository'
          
          - task: DownloadPipelineArtifact@2
            displayName: 'Download SSH Keys'
            inputs:
              buildType: 'current'
              artifactName: 'ssh-keys'
              targetPath: '$(Agent.TempDirectory)/ssh-keys'
          
          - task: AzureCLI@2
            displayName: 'Deploy Infrastructure with Terraform'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e  # Exit on any error
                
                # Install Terraform
                echo "Installing Terraform..."
                wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
                echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
                sudo apt update && sudo apt install terraform
                
                echo "Starting Terraform deployment..."
                
                # Set unique resource names
                UNIQUE_SUFFIX=$(echo $(Build.BuildId) | tail -c 5)
                RESOURCE_GROUP_NAME="$(resource_group_prefix)-$UNIQUE_SUFFIX"
                VM_NAME="$(vm_name_prefix)-$UNIQUE_SUFFIX"
                
                echo "Resource Group: $RESOURCE_GROUP_NAME"
                echo "VM Name: $VM_NAME"
                
                # Debug SSH Key
                echo "=== SSH KEY DEBUGGING ==="
                echo "SSH Public Key (first 50 chars): $(echo '$(ssh_public_key)' | cut -c1-50)..."
                echo "SSH Public Key length: $(echo '$(ssh_public_key)' | wc -c)"
                
                if [ -z "$(ssh_public_key)" ]; then
                  echo "âŒ ERROR: SSH Public Key is empty!"
                  echo "This will cause Terraform to fail."
                  exit 1
                fi
                echo "âœ… SSH Public Key is present"
                echo "========================="
                
                # Debug: Show Azure context
                echo "Azure CLI context:"
                az account show
                
                cd terraform
                
                # Initialize Terraform
                echo "Initializing Terraform..."
                terraform init
                
                # Plan deployment
                echo "Planning Terraform deployment..."
                terraform plan \
                  -var="resource_group_name=$RESOURCE_GROUP_NAME" \
                  -var="location=$(location)" \
                  -var="vm_name=$VM_NAME" \
                  -var="admin_username=$(admin_username)" \
                  -var="admin_ssh_key=$(ssh_public_key)" \
                  -var="github_repo_url=$(Build.Repository.Uri)" \
                  -var="app_name=$(app_name)" \
                  -var="github_token=" \
                  -out=tfplan
                
                # Apply deployment
                echo "Applying Terraform deployment..."
                if terraform apply -auto-approve tfplan; then
                  echo "âœ… Terraform apply completed successfully"
                else
                  echo "âŒ Terraform apply failed!"
                  echo "Terraform state:"
                  terraform show || echo "No state to show"
                  echo "Terraform output:"
                  terraform output || echo "No outputs available"
                  exit 1
                fi
                
                # Verify deployment
                echo "Verifying Terraform state..."
                terraform show
                
                # Get outputs with error checking and fallbacks
                echo "Getting Terraform outputs..."
                
                # Try to get VM public IP
                if terraform output vm_public_ip; then
                  VM_PUBLIC_IP=$(terraform output -raw vm_public_ip)
                  echo "VM Public IP from Terraform: $VM_PUBLIC_IP"
                else
                  echo "WARNING: vm_public_ip output not found, trying Azure CLI fallback..."
                  # Fallback: Get public IP directly from Azure CLI
                  VM_PUBLIC_IP=$(az network public-ip show --resource-group "$RESOURCE_GROUP_NAME" --name "${VM_NAME}-pip" --query ipAddress --output tsv 2>/dev/null || echo "")
                  if [ -n "$VM_PUBLIC_IP" ]; then
                    echo "VM Public IP from Azure CLI: $VM_PUBLIC_IP"
                  else
                    echo "ERROR: Could not get VM public IP from Terraform or Azure CLI"
                    terraform output || echo "No outputs available"
                    exit 1
                  fi
                fi
                
                # Try to get VM private IP
                if terraform output vm_private_ip; then
                  VM_PRIVATE_IP=$(terraform output -raw vm_private_ip)
                  echo "VM Private IP: $VM_PRIVATE_IP"
                else
                  echo "WARNING: vm_private_ip output not found"
                  VM_PRIVATE_IP=""
                fi
                
                # Generate SSH connection string
                if [ -n "$VM_PUBLIC_IP" ]; then
                  SSH_CONNECTION="ssh $(admin_username)@$VM_PUBLIC_IP"
                  echo "SSH Connection: $SSH_CONNECTION"
                else
                  echo "ERROR: Cannot generate SSH connection without public IP"
                  exit 1
                fi
                
                # Set pipeline variables
                echo "Setting pipeline variables..."
                echo "##vso[task.setvariable variable=vm_public_ip;isOutput=true]$VM_PUBLIC_IP"
                echo "##vso[task.setvariable variable=vm_private_ip;isOutput=true]$VM_PRIVATE_IP"
                echo "##vso[task.setvariable variable=ssh_connection;isOutput=true]$SSH_CONNECTION"
                echo "##vso[task.setvariable variable=resource_group_name;isOutput=true]$RESOURCE_GROUP_NAME"
                echo "##vso[task.setvariable variable=vm_name;isOutput=true]$VM_NAME"
                
                # Verify variables were set
                echo "=== VERIFYING PIPELINE VARIABLES ==="
                echo "vm_public_ip: $VM_PUBLIC_IP"
                echo "vm_private_ip: $VM_PRIVATE_IP"
                echo "ssh_connection: $SSH_CONNECTION"
                echo "resource_group_name: $RESOURCE_GROUP_NAME"
                echo "vm_name: $VM_NAME"
                echo "===================================="
                
                echo "Infrastructure deployed successfully!"
                echo "VM Public IP: $VM_PUBLIC_IP"
                echo "SSH Connection: $SSH_CONNECTION"
            name: 'TerraformDeploy'

- stage: 'Validate_Deployment'
  displayName: 'Validate Application Deployment'
  dependsOn: 'Deploy'
  variables:
    vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_public_ip'] ]
    ssh_connection: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.ssh_connection'] ]
    resource_group_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.resource_group_name'] ]
    vm_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_name'] ]
  
  jobs:
  - job: 'TestApplication'
    displayName: 'Test Application and SSH Access'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download SSH Keys'
      inputs:
        buildType: 'current'
        artifactName: 'ssh-keys'
        targetPath: '$(Agent.TempDirectory)/ssh-keys'
    
    - script: |
        echo "=== DEBUGGING PIPELINE VARIABLES ==="
        echo "VM Public IP: '$(vm_public_ip)'"
        echo "SSH Connection: '$(ssh_connection)'"
        echo "Resource Group: '$(resource_group_name)'"
        echo "VM Name: '$(vm_name)'"
        echo "====================================="
        
        # Check if variables are empty
        if [ -z "$(vm_public_ip)" ]; then
          echo "âŒ ERROR: VM Public IP is empty!"
          echo "This indicates the Terraform deployment may have failed."
          echo "Check the previous 'Deploy Infrastructure with Terraform' task for errors."
          exit 1
        fi
        
        if [ -z "$(ssh_connection)" ]; then
          echo "âŒ ERROR: SSH Connection is empty!"
          exit 1
        fi
        
        echo "âœ… All variables are populated correctly"
        echo "Waiting for VM setup to complete..."
        echo "VM Public IP: $(vm_public_ip)"
        echo "SSH Connection: $(ssh_connection)"
        
        # Wait for VM extension to complete setup
        sleep 120
      displayName: 'Wait for VM Setup'
    
    - script: |
        echo "Testing application endpoints..."
        VM_IP="$(vm_public_ip)"
        
        # Test application health (with retries)
        for i in {1..20}; do
          echo "Attempt $i/20: Testing health endpoint..."
          if curl -f -s "http://$VM_IP/health"; then
            echo "âœ… Application is healthy!"
            break
          else
            echo "â³ Application not ready yet, waiting 30 seconds..."
            sleep 30
          fi
          
          if [ $i -eq 20 ]; then
            echo "âŒ Application failed to start within 10 minutes"
            exit 1
          fi
        done
        
        echo "Testing other endpoints..."
        
        # Test home page
        echo "Testing home page..."
        curl -f -s "http://$VM_IP/" > /dev/null && echo "âœ… Home page OK" || echo "âŒ Home page failed"
        
        # Test API endpoints
        echo "Testing API endpoints..."
        curl -f -s "http://$VM_IP/api/info" > /dev/null && echo "âœ… API info OK" || echo "âŒ API info failed"
        curl -f -s "http://$VM_IP/api/hello?name=AzureDevOps" > /dev/null && echo "âœ… API hello OK" || echo "âŒ API hello failed"
        
        echo "âœ… All endpoint tests completed!"
      displayName: 'Test Application Endpoints'
    
    - script: |
        echo "Testing SSH access..."
        
        # Setup SSH key
        mkdir -p ~/.ssh
        cp $(Agent.TempDirectory)/ssh-keys/ssh_private_key ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        VM_IP="$(vm_public_ip)"
        
        # Add VM to known hosts
        ssh-keyscan -H $VM_IP >> ~/.ssh/known_hosts
        
        # Test SSH connection
        echo "Testing SSH connection to $(admin_username)@$VM_IP..."
        ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no $(admin_username)@$VM_IP "echo 'SSH connection successful!' && hostname && uptime"
        
        # Test application status on VM
        echo "Checking application status on VM..."
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "sudo systemctl status nginx --no-pager -l"
        ssh -o ConnectTimeout=30 $(admin_username)@$VM_IP "sudo supervisorctl status $(app_name)"
        
        echo "âœ… SSH access test completed successfully!"
      displayName: 'Test SSH Access'
    
    - task: AzureCLI@2
      displayName: 'Generate Deployment Summary'
      inputs:
        azureSubscription: $(azureServiceConnection)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "## ðŸš€ Deployment Summary" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### ðŸ“‹ Infrastructure Details" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Resource Group**: $(resource_group_name)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **VM Name**: $(vm_name)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **VM Public IP**: $(vm_public_ip)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Location**: $(location)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### ðŸ”— Application URLs" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Application Home**: http://$(vm_public_ip)/" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Health Check**: http://$(vm_public_ip)/health" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **System Status**: http://$(vm_public_ip)/status" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **API Info**: http://$(vm_public_ip)/api/info" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### ðŸ”‘ SSH Access" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "```bash" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "ssh $(admin_username)@$(vm_public_ip)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "```" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "### ðŸ“Š Pipeline Information" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Build ID**: $(Build.BuildId)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Build Number**: $(Build.BuildNumber)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Source Branch**: $(Build.SourceBranch)" >> $(Agent.TempDirectory)/deployment_summary.md
          echo "- **Deployment Time**: $(date)" >> $(Agent.TempDirectory)/deployment_summary.md
          
          echo "Deployment completed successfully! ðŸŽ‰"
          cat $(Agent.TempDirectory)/deployment_summary.md
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Deployment Summary'
      inputs:
        targetPath: '$(Agent.TempDirectory)/deployment_summary.md'
        artifact: 'deployment-summary'
        publishLocation: 'pipeline'

- stage: 'Cleanup'
  displayName: 'Cleanup Resources (Optional)'
  dependsOn: ['Deploy', 'Validate_Deployment']
  condition: and(succeeded(), eq(variables['cleanup_resources'], 'true'))
  variables:
    resource_group_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.resource_group_name'] ]
  
  jobs:
  - job: 'CleanupInfrastructure'
    displayName: 'Cleanup Azure Resources'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: AzureCLI@2
      displayName: 'Destroy Infrastructure'
      inputs:
        azureSubscription: $(azureServiceConnection)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Starting infrastructure cleanup..."
          echo "Resource Group: $(resource_group_name)"
          
          # Delete the entire resource group (faster than Terraform destroy)
          az group delete --name "$(resource_group_name)" --yes --no-wait
          
          echo "âœ… Cleanup initiated successfully!"