trigger:
- main

variables:
  app_name: 'flask-app'
  admin_username: 'azureuser'
  admin_password: 'TerraformDemo@2024!'
  environment: 'dev'
  location: 'East US'
  vm_size: 'Standard_B2s'

stages:
# Validate Stage
- stage: 'Validate'
  displayName: 'Validate Terraform Configuration'
  jobs:
  - job: 'ValidateTerraform'
    displayName: 'Validate Terraform'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - script: |
        cd terraform
        terraform init
        terraform validate
      displayName: 'Validate Terraform Configuration'

# Setup Stage
- stage: 'Setup'
  displayName: 'Setup Environment'
  dependsOn: 'Validate'
  jobs:
  - job: 'SetupEnvironment'
    displayName: 'Setup Environment'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - script: |
        # Install required packages
        wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
        sudo apt update
        sudo apt install -y terraform sshpass
      displayName: 'Install Required Tools'

# Deploy Infrastructure Stage  
- stage: 'Deploy'
  displayName: 'Deploy Infrastructure'
  dependsOn: 'Setup'
  
  jobs:
  - job: 'DeployInfrastructure'
    displayName: 'Deploy with Terraform'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: AzureCLI@2
      displayName: 'Deploy Infrastructure'
      name: 'TerraformDeploy'
      inputs:
        azureSubscription: '$(serviceConnectionName)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
            # Install Terraform
            wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg >/dev/null
            echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list >/dev/null
            sudo apt update >/dev/null
            sudo apt install -y terraform sshpass >/dev/null
            
            # Setup Terraform working directory
            cd terraform
            
            # Generate unique suffix to avoid naming conflicts
            UNIQUE_SUFFIX=$(date +%s | tail -c 4)
            RESOURCE_GROUP_NAME="rg-$(app_name)-$(environment)-$UNIQUE_SUFFIX"
            VM_NAME="vm-$(app_name)-$(environment)-$UNIQUE_SUFFIX"
            
            # Initialize and apply Terraform
            terraform init >/dev/null
            
            terraform apply -auto-approve \
              -var="app_name=$(app_name)" \
              -var="admin_username=$(admin_username)" \
              -var="admin_password=$(admin_password)" \
              -var="environment=$(environment)" \
              -var="location=$(location)" \
              -var="vm_size=$(vm_size)" \
              -var="resource_group_name=$RESOURCE_GROUP_NAME" \
              -var="vm_name=$VM_NAME"
            
            if [ $? -ne 0 ]; then
              echo "ERROR: Terraform apply failed!"
              exit 1
            fi
            
            # Get VM public IP
            VM_PUBLIC_IP=$(terraform output -raw vm_public_ip 2>/dev/null)
            if [ -z "$VM_PUBLIC_IP" ] || [ "$VM_PUBLIC_IP" = "null" ]; then
              # Fallback to Azure CLI
              EXPECTED_PIP_NAME="${VM_NAME}-pip"
              VM_PUBLIC_IP=$(az network public-ip show --resource-group "$RESOURCE_GROUP_NAME" --name "$EXPECTED_PIP_NAME" --query ipAddress --output tsv 2>/dev/null)
              if [ -z "$VM_PUBLIC_IP" ] || [ "$VM_PUBLIC_IP" = "null" ]; then
                echo "ERROR: Could not retrieve VM public IP"
                exit 1
              fi
            fi
            
            # Set pipeline variables
            echo "##vso[task.setvariable variable=vm_public_ip;isOutput=true]$VM_PUBLIC_IP"
            echo "##vso[task.setvariable variable=resource_group_name;isOutput=true]$RESOURCE_GROUP_NAME"
            echo "##vso[task.setvariable variable=vm_name;isOutput=true]$VM_NAME"

# Package Application Stage
- stage: 'Package_Application'
  displayName: 'Package Application'
  dependsOn: 'Setup'
  jobs:
  - job: 'PackageApp'
    displayName: 'Package Application Files'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - script: |
        # Create temp directory for application files
        mkdir -p $(Agent.TempDirectory)/app-files
        
        # Copy application files
        if [ -d "sample-python-app" ]; then
          cp -r sample-python-app/* $(Agent.TempDirectory)/app-files/
        else
          echo "ERROR: sample-python-app directory not found"
          exit 1
        fi
      displayName: 'Package Application Files'
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Application Files'
      inputs:
        targetPath: '$(Agent.TempDirectory)/app-files'
        artifact: 'application-files'

# Deploy Application Stage
- stage: 'Deploy_Application'
  displayName: 'Deploy Application to VM'
  dependsOn: ['Deploy', 'Package_Application']
  variables:
    vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_public_ip'] ]
    resource_group_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.resource_group_name'] ]
    vm_name: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_name'] ]
  
  jobs:
  - job: 'DeployToVM'
    displayName: 'Deploy Application to VM'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Application Files'
      inputs:
        buildType: 'current'
        artifactName: 'application-files'
        targetPath: '$(Agent.TempDirectory)/app-files'
    
    - script: |
        # Install sshpass for password authentication
        sudo apt update >/dev/null
        sudo apt install -y sshpass >/dev/null
        
        # Get VM IP with fallback logic
        VM_IP="$(vm_public_ip)"
        if [ -z "$VM_IP" ] || [ "$VM_IP" = "null" ]; then
          # Try to get from Azure CLI as fallback
          RESOURCE_GROUP="$(resource_group_name)"
          VM_NAME="$(vm_name)"
          
          if [ -n "$RESOURCE_GROUP" ] && [ -n "$VM_NAME" ]; then
            PIP_NAME=$(az network public-ip list --resource-group "$RESOURCE_GROUP" --query "[0].name" --output tsv 2>/dev/null)
            if [ -n "$PIP_NAME" ] && [ "$PIP_NAME" != "null" ]; then
              VM_IP=$(az network public-ip show --resource-group "$RESOURCE_GROUP" --name "$PIP_NAME" --query ipAddress --output tsv 2>/dev/null)
            fi
          fi
        fi
        
        if [ -z "$VM_IP" ] || [ "$VM_IP" = "null" ]; then
          echo "ERROR: VM IP is not available!"
          exit 1
        fi
        
        # Test connection with password authentication
        sshpass -p "$(admin_password)" ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no $(admin_username)@$VM_IP "echo 'SSH connected'" >/dev/null
        
        # Create application directory and copy files
        APP_NAME="$(app_name)"
        sshpass -p "$(admin_password)" ssh -o StrictHostKeyChecking=no $(admin_username)@$VM_IP "mkdir -p /home/$(admin_username)/$APP_NAME"
        sshpass -p "$(admin_password)" scp -o StrictHostKeyChecking=no -r $(Agent.TempDirectory)/app-files/* $(admin_username)@$VM_IP:/home/$(admin_username)/$APP_NAME/ >/dev/null
        
        # Copy and run setup script
        sshpass -p "$(admin_password)" scp -o StrictHostKeyChecking=no terraform/scripts/setup.sh $(admin_username)@$VM_IP:/tmp/setup.sh
        sshpass -p "$(admin_password)" ssh -o StrictHostKeyChecking=no $(admin_username)@$VM_IP "echo '$(admin_password)' | sudo -S bash /tmp/setup.sh '$(app_name)' '$(admin_username)'"
        
        echo "Application deployed successfully"
      displayName: 'Deploy Application to VM'

# Validation Stage
- stage: 'Validate_Deployment'
  displayName: 'Final Validation and Testing'
  dependsOn: 'Deploy_Application'
  variables:
    vm_public_ip: $[ stageDependencies.Deploy.DeployInfrastructure.outputs['TerraformDeploy.vm_public_ip'] ]
  
  jobs:
  - job: 'ValidateApp'
    displayName: 'Validate Application'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - script: |
        VM_IP="$(vm_public_ip)"
        
        # Wait for application to be ready
        sleep 30
        
        # Test application endpoints
        if curl -f -s "http://$VM_IP/health" >/dev/null; then
          echo "Application validation successful"
        else
          echo "ERROR: Application validation failed"
          exit 1
        fi
      displayName: 'Test Application'